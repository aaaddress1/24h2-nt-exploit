#include "find_nt_offsets.h"

// these are the same but for type convenience im keeping them duped
UINT_PTR nt_base = 0;
HANDLE h_nt = 0;

// capstone globals
csh handle = 0;

// offset globals
UINT64 offset_NtBuildNumber = 0;
UINT64 offset_MmPfnDatabase = 0;
UINT64 offset_PsLoadedModuleList = 0;
UINT64 offset_PsActiveProcessHead = 0;
UINT64 offset_ExpManufacturingInformation = 0;

UINT64 get_insn_imm(cs_insn* insn)
{
	if (insn[0].detail == 0)
	{
		return 0;
	}
	if (insn[0].detail->x86.op_count != 2)
	{
		return 0;
	}
	if (insn[0].detail->x86.operands[1].type != X86_OP_IMM)
	{
		return 0;
	}

	return insn[0].detail->x86.operands[1].imm;
}

UINT64 get_insn_rip_relative_ptr(cs_insn* insn)
{
	if (insn[0].detail == 0)
	{
		return 0;
	}
	if (insn[0].detail->x86.op_count != 2)
	{
		return 0;
	}
	if (insn[0].detail->x86.operands[1].type != X86_OP_MEM)
	{
		return 0;
	}

	if (insn[0].detail->x86.operands[1].mem.base != X86_REG_RIP)
	{
		return 0;
	}

	return insn[1].address + insn[0].detail->x86.operands[1].mem.disp;
}

UINT_PTR addr_to_offset(UINT_PTR addr)
{
	return addr - nt_base;
}

SIZE_T find_function_len(UINT_PTR func)
{
	ULONG cc_count = 0;
	BYTE* cur_ptr = func;

	while (1)
	{

		if (*cur_ptr == 0xCC)
		{
			cc_count++;
		}
		else
		{
			cc_count = 0;
		}
		cur_ptr++;

		if (cc_count >= 2 && ((UINT_PTR)cur_ptr % 0x10) == 0)
		{
			break;
		}
	}

	return ((SIZE_T)cur_ptr - func);
}

VOID find_offset_ExpManufacturingInformation()
{
	UINT_PTR ExIsManufacturingModeEnabled = GetProcAddress(h_nt, "ExIsManufacturingModeEnabled");
	if (ExIsManufacturingModeEnabled == 0)
	{
		printf("Unable to find ExIsManufacturingModeEnabled!\n");
		return 0;
	}
	UINT_PTR func_len = find_function_len(ExIsManufacturingModeEnabled);

	cs_insn* insn;
	size_t count;

	count = cs_disasm(handle, ExIsManufacturingModeEnabled, func_len, addr_to_offset(ExIsManufacturingModeEnabled), 0, &insn);

	if (count < 2)
	{
		return 0;
	}

	// first instruction:
	// 0x6f78a0:       mov             al, byte ptr[rip + 0x525f3a]
	//		op 0 REG 2
	//		op 1 MEM base 41 disp 00525f3a index 0 scale 1 segment 0
	if (insn[0].detail == 0)
	{
		return 0;
	}
	if (insn[0].detail->x86.op_count != 2)
	{
		return 0;
	}
	if (insn[0].detail->x86.operands[1].type != X86_OP_MEM)
	{
		return 0;
	}

	UINT64 result = insn[1].address + insn[0].detail->x86.operands[1].mem.disp;
	cs_free(insn, count);
	//cs_close(handle);

	offset_ExpManufacturingInformation = result;
}

typedef enum _scan_KeCapturePersistentThreadState {
	load1_NtBuildNumber,
	load2_NtBuildNumber,
	load3_MmPfnDatabase,
	load4_PsLoadedModuleList,
	load5_PsActiveProcessHead,
	scan_KeCapturePersistentThreadState_MAX,
} scan_KeCapturePersistentThreadState;

VOID find_offset_PsActiveProcessHead()
{
	UINT_PTR KeCapturePersistentThreadState = GetProcAddress(h_nt, "KeCapturePersistentThreadState");
	UINT_PTR KeCapturePersistentThreadState_offset = addr_to_offset(KeCapturePersistentThreadState);

	UINT_PTR func_len = find_function_len(KeCapturePersistentThreadState);

	cs_insn* insn;
	size_t count;
	BOOL magic_found = FALSE;

	count = cs_disasm(handle, KeCapturePersistentThreadState, func_len, KeCapturePersistentThreadState_offset, 0, &insn);
	if (count > 0) {
		size_t j;
		scan_KeCapturePersistentThreadState cur_scan = 0;
		for (UINT i = 0; i < count; i++) {

			UINT64 imm = get_insn_imm(&insn[i]);
			if (imm == 0x34365544)
			{
				magic_found = TRUE;
				continue;
			}

			if (magic_found && (i < count - 2))
			{
				UINT64 global_ptr = get_insn_rip_relative_ptr(&insn[i]);
				if (global_ptr == 0)
				{
					continue;
				}

				switch (cur_scan) {
				case load1_NtBuildNumber:
					offset_NtBuildNumber = global_ptr;
					break;
				case load2_NtBuildNumber:
					if (global_ptr != offset_NtBuildNumber) {
						printf("NtBuildNumber mismatch! offsets unreliable, aborting.\n");
						exit(0);
					}
					break;
				case load3_MmPfnDatabase:
					offset_MmPfnDatabase = global_ptr;
					break;
				case load4_PsLoadedModuleList:
					offset_PsLoadedModuleList = global_ptr;
					break;
				case load5_PsActiveProcessHead:
					offset_PsActiveProcessHead = global_ptr;
					break;
				default:
					break;
				}

				cur_scan++;
			}
		}

		cs_free(insn, count);
	}
	else
		printf("ERROR: Failed to disassemble given code!\n");
	return 0;
}

UINT64 get_offset_test()
{
	UINT_PTR ExIsManufacturingModeEnabled = GetProcAddress(h_nt, "ExIsManufacturingModeEnabled");
	if (ExIsManufacturingModeEnabled == 0)
	{
		printf("Unable to find ExIsManufacturingModeEnabled!\n");
		return 0;
	}
	UINT_PTR func_len = find_function_len(ExIsManufacturingModeEnabled);

	cs_insn* insn;
	size_t count;

	count = cs_disasm(handle, ExIsManufacturingModeEnabled, func_len, addr_to_offset(ExIsManufacturingModeEnabled), 0, &insn);
}

VOID init_find_nt_offsets(const char* nt_path)
{
	h_nt = LoadLibraryExA(nt_path, NULL, DONT_RESOLVE_DLL_REFERENCES);
	nt_base = h_nt;

	if (cs_open(CS_ARCH_X86, CS_MODE_64, &handle) != CS_ERR_OK)
	{
		printf("cs_open failed!\n");
	}

	cs_option(handle, CS_OPT_DETAIL, CS_OPT_ON);

	find_offset_PsActiveProcessHead();
	find_offset_ExpManufacturingInformation();
}

UINT64 get_offset_PsActiveProcessHead()
{
	return offset_PsActiveProcessHead;
}

UINT64 get_offset_PsLoadedModuleList()
{
	return offset_PsLoadedModuleList;
}

UINT64 get_offset_MmPfnDatabase()
{
	return offset_MmPfnDatabase;
}

UINT64 get_offset_NtBuildNumber()
{
	return offset_NtBuildNumber;
}

UINT64 get_offset_ExpManufacturingInformation()
{
	return offset_ExpManufacturingInformation;
}